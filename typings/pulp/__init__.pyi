"""
Pyright cannot understand PuLP's DSL because the published package lacks typing stubs.
These handwritten declarations expose the arithmetic, comparison, and solver API we use so the builder
can rely on built-in operators instead of ad-hoc casts.
"""

from __future__ import annotations

# pyright: reportIncompatibleMethodOverride=false

from typing import Iterable, TypeVar

_Index = TypeVar("_Index")

class LpAffineExpression:
    def __init__(self) -> None: ...
    def __add__(self, other: object) -> "LpAffineExpression": ...
    def __radd__(self, other: object) -> "LpAffineExpression": ...
    def __sub__(self, other: object) -> "LpAffineExpression": ...
    def __rsub__(self, other: object) -> "LpAffineExpression": ...
    def __mul__(self, other: object) -> "LpAffineExpression": ...
    def __rmul__(self, other: object) -> "LpAffineExpression": ...
    def __neg__(self) -> "LpAffineExpression": ...
    def __iadd__(self, other: object) -> "LpAffineExpression": ...
    def __isub__(self, other: object) -> "LpAffineExpression": ...
    def __imul__(self, other: object) -> "LpAffineExpression": ...
    def __eq__(self, other: object) -> "LpConstraint": ...
    def __ne__(self, other: object) -> "LpConstraint": ...
    def __le__(self, other: object) -> "LpConstraint": ...
    def __ge__(self, other: object) -> "LpConstraint": ...
    def __lt__(self, other: object) -> "LpConstraint": ...
    def __gt__(self, other: object) -> "LpConstraint": ...
    def __truediv__(self, other: object) -> "LpAffineExpression": ...
    def __rtruediv__(self, other: object) -> "LpAffineExpression": ...
    def items(self) -> Iterable[tuple["LpVariable", float]]: ...
    def get(self, var: "LpVariable", default: float | None = None) -> float | None: ...

class LpConstraint(LpAffineExpression): ...

class LpVariable(LpAffineExpression):
    def __init__(
        self,
        name: str,
        lowBound: float | None = None,
        upBound: float | None = None,
        cat: str | None = None,
    ) -> None: ...
    @classmethod
    def dicts(
        cls,
        name: str,
        indices: Iterable[_Index],
        *,
        lowBound: float | None = None,
        upBound: float | None = None,
        cat: str | None = None,
    ) -> dict[_Index, "LpVariable"]: ...

class LpSolver:
    def __init__(self, msg: bool = ..., **kwargs: object) -> None: ...

class PULP_CBC_CMD(LpSolver): ...

class LpProblem:
    def __init__(self, name: str | None = None, sense: int | None = None) -> None: ...
    def __iadd__(self, other: object) -> "LpProblem": ...
    def __add__(self, other: object) -> "LpProblem": ...
    def solve(self, solver: LpSolver | None = None) -> int: ...

    objective: LpAffineExpression | None
    status: int

LpMinimize: int
LpStatus: dict[int, str]

def lpSum(values: Iterable[LpAffineExpression]) -> LpAffineExpression: ...
def value(x: LpAffineExpression | LpVariable | None) -> float | None: ...
