"""
Pyright cannot understand PuLP's DSL because the published package lacks typing stubs.
These handwritten declarations expose the arithmetic, comparison, and solver API we use so the builder
can rely on built-in operators instead of ad-hoc casts.
"""

from __future__ import annotations

# pyright: reportIncompatibleMethodOverride=false

from typing import Iterable, TypeVar

_Index = TypeVar("_Index")

class LpAffineExpression:
    def __init__(self) -> None: ...
    def __add__(self, other: object) -> "LpAffineExpression": ...
    def __radd__(self, other: object) -> "LpAffineExpression": ...
    def __sub__(self, other: object) -> "LpAffineExpression": ...
    def __rsub__(self, other: object) -> "LpAffineExpression": ...
    def __mul__(self, other: object) -> "LpAffineExpression": ...
    def __rmul__(self, other: object) -> "LpAffineExpression": ...
    def __neg__(self) -> "LpAffineExpression": ...
    def __iadd__(self, other: object) -> "LpAffineExpression": ...
    def __isub__(self, other: object) -> "LpAffineExpression": ...
    def __imul__(self, other: object) -> "LpAffineExpression": ...
    def __eq__(self, other: object) -> "LpConstraint": ...
    def __ne__(self, other: object) -> "LpConstraint": ...
    def __le__(self, other: object) -> "LpConstraint": ...
    def __ge__(self, other: object) -> "LpConstraint": ...
    def __lt__(self, other: object) -> "LpConstraint": ...
    def __gt__(self, other: object) -> "LpConstraint": ...
    def __truediv__(self, other: object) -> "LpAffineExpression": ...
    def __rtruediv__(self, other: object) -> "LpAffineExpression": ...

class LpConstraint(LpAffineExpression): ...

class LpVariable(LpAffineExpression):
    def __init__(
        self,
        name: str,
        lowBound: float | None = None,
        upBound: float | None = None,
        cat: str | None = None,
    ) -> None: ...
    @classmethod
    def dicts(
        cls,
        name: str,
        indices: Iterable[_Index],
        *,
        lowBound: float | None = None,
        upBound: float | None = None,
        cat: str | None = None,
    ) -> dict[_Index, "LpVariable"]: ...

class LpProblem:
    def __init__(self, name: str | None = None, sense: int | None = None) -> None: ...
    def __iadd__(self, other: object) -> "LpProblem": ...
    def __add__(self, other: object) -> "LpProblem": ...

    objective: LpAffineExpression | None

LpMinimize: int

def lpSum(values: Iterable[LpAffineExpression]) -> LpAffineExpression: ...
